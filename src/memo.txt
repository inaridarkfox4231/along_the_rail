どうしよっかな。
白：当たるとゲームオーバー
残機数が減って最初からです。0になったらおわりです。
消えるとき、線を引いて出現させるときなどパーティクル実装おねがいです。
ボールはオレンジで引く線は水色でいきます。
当たると
円形のレールも用意して勝手に乗っちゃうの。そういうのもギミックとして追加する。

薄い緑：通常のレール。
白：やられる
赤：レールに乗ってなければやられない
青：レールに乗っていればやられない
黄色：普通に乗れるが乗ってる間だけスピードアップ（ファクターをいじる）
茶色：普通に乗れるが乗ってる間だけスピードダウン（ファクターをいじる）
濃い緑：当たると反射する、何回か反射すると消える
濃い目の水色：加速していないとやられる（加速していればOKでスピードは無関係）

アクションにしてもいいかなって思ったの。ボタンでジャンプして離脱するみたいな。重力実装して。
レールによって、十字キーで動けるか、または強制的に動かされるか。
往復する場合もあるし、端っこに来た時の挙動とかもいろいろ、単に折り返すか、そのまま飛び出すかみたいな。
方向を変えるギミックとか用意すれば・・で、ステージをくっつけたり。スクロールでもいいけど。

三角や四角形あってもいいけどとりあえず円と直線だけでいろいろできそうなのよね。

タイプ0:通過するとやられるやつ。
タイプ1:上に乗れる。ジャンプで離脱。シフトで離脱、ジャンプボタンと左右キーでジャンプ、そこら辺は一緒。
       端っこについては外れる場合と外れない場合がある。
タイプ2:一定の方向に流される。はしっこで強制的に外れる。
タイプ3:行ったり来たりする。どっちに流されるかはポインター（たとえば直交する線分）を見ると分かる感じ。
はしっこでは方向が逆転するまで止まらされる（ジャンプなどでの離脱は可能）。
で、サークルタイプのやつとか。一定時間ごとに向きが変わったりすると面白いかも。
あとは、レールに乗ってるときだけやられるとか、乗ってない時だけやられるとか。
逆らってジャンプで進まないといけないところとかありそうで面白そうね（？？）
外れることができないレールとかもありそうだな・・・タイプ4とか？
レールから外れるときは強制的に速度が固定される。そこら辺は今の仕様そのままでいいと思う。
時間をおいてその間は乗れないのとかも。

十字キーでどっちに進むか？接線情報を設けてそれと上下左右で取って直交してなければその方向に行く感じ。あんま小さければ動けないようにするけど。
赤レール：通過するとやられる
白レール：ごく普通のレール。縦、横、斜め。十字キーで移動。ジャンプで離脱、シフトで直接離脱、その場合は普通に速度計算（previous使って）。
端っこで離脱するかどうかは直交する線分で明示。それがある場合は離脱できない感じ。
青レール：ポインターが走っていて、その方向に強制的に流される。十字キー操作は無効。離脱は普通に可能。
ポインターの向きが変わることがありその場合は行ったり来たりする。端っこで（以下略）。
黄色レール：外れることができない。ずっと動きっぱなし。端っこに来ないと離脱できない。強制移動ね。だから端っこは解放されている（でないとやばい）。

レールに乗ってる間は緑色のオーラみたいなのが出るようにして。。通常時はピンクのオーラでいい？分かりやすいでしょその方が。
緑レール：レールに乗ってる状態で通過すればやられない。レールに乗ってない状態で通過するとアウト。
ピンクレール：逆にレールに乗ってる状態で通過するとアウト。だから通過するにはレールを外れないといけない。
レールではないな。まあいいや。（？）
例えばだけど空中にアイテムあったらジャンプとかしないと取れないから外れざるを得ないみたいなのを想定してる。緑レールはそんな感じ。
逆にピンクレールは強制移動とかあったらジャンプして外れないとやばいみたいなのを想定してる。ステージ作るの大変そうね・・。
それらとは別に当たったらやられるオブジェクトを走らせるのも面白いかも。勝手に折り返したりする。たとえば白レールの上を走らせて邪魔したりとか。
透明レール：敵を動かすためだけに用意されたレール。プレイヤーが触れても何も起こらない。
点滅してダメージ受けるだけにした方がいいかもだね・・赤レールは即死でいいよ。え？
攻撃ができないので普通にステージクリア形式になるのかなぁ（知らんけど）。

なんかひとつステージ作ってみてよ。雑に。
スクロール久しぶりだから忘れてる？描画をおさまるものに限るだけよ。難しくない。
背景はモノクロにするけどいろいろパターン欲しい。チェック、トライアングル、あとまあ、白黒の青海波とかいろいろ。GLSLのが描きやすいかも。
真っ黒でいいか、とりあえず。

アイデアばっか書いてても進まないのでいい加減実装しようかな。とりあえずオブジェクトの他にプレイヤー・・
それはねぇ、継承でENEMYとPLAYERした方がいいと思うのよね。

そういえばlifeとかあるけどこれデフォルトで無限みたいになる？消えても面白いよね。
一定時間たつと消える白いレール、また復活、そういうのを乗り継いでジャンプで渡っていくみたいなの想像してた。
それが上下するとか。

色々変更
白レール：ごく普通のレール。乗っている間自由に十字キーで移動可能。離脱にはボタンを使う。
薄い水色レール：ポインターが走っててそれに従ってproportionを動かされる。離脱は普通に可能。
薄い緑レール：強制的に移動させられる。ゆえに一方通行で端っこで投げ出される
共に端っこにストッパーがあったりなかったりする。
常に赤いオーラをまとっている。レールに乗っていると青いオーラになる。
黄色レール：通過すると一発アウト
赤レール：すっぴんの状態で通過できるがレールに乗った状態だと一発アウト
青レール：レールに乗った状態で通過できるがすっぴんの状態だと一発アウト

敵が乗った場合は従来通り勝手に往復する。すべてのレールが対象である。ムーブレール、ダメージレール問わず普通に動くし大きければ当たり判定も大きい。
プレーヤーはブリンクしてその間は無敵。ラインに関しては一発アウト。でないとギミックの意味がないので。

普通に今のままでいい。オーラは消す。
パーティクルを放出してはじけ飛ぶ。60フレーム後に残機があればセーブポイントから再開、無ければゲームオーバー判定。
そこら辺はぼちぼちって感じですかね・・

あと多角形のレールはやめようかなと。線分組み合わせればいいので。

はい。
ストッパー、ポインター、ダメージ情報。この辺。を、attribute（今使ってない情報）で決める。
ダメージレールかムーブレールか、さらに・・って感じ。
stopperとかpointerはいろいろなので作ってから設定する方がいいかもしれない。constructorに全部放り込むより。

敵に関しては従来通りでいいや。今やってる、この通りで。そんで、こっちだけいろいろ、みたいな。
reverseがtrueでかつ端っこに来た時に、敵によっては放り出されて自由落下する、もしくはそのまま往復、みたいにする。
さらにそれとは別に勝手な動きをする敵を用意する。以上。

攻撃・・今考えてるのは周囲攻撃。オーラが広がって当たった敵がスリップダメージ、的な感じの。
レールに乗ってるときは青いオーラが広がって周囲攻撃、乗ってない時は赤い弾丸みたいのが最後に入力した左右キーの方向に発射される。
パワーアップでレールに乗ってても遠隔、あるいは乗ってなくても近接、みたいになったり？書けるだけ書いちゃう。

しかたない
つぶやきなんちゃらが猛威を振るってる以上、ここまでやらないとクソプログラム認定されちゃうわけだから。
ここまでやらないと。結局0か、1かなんだよ。
一生懸命つくってるものをクソ扱いされたくない。これ以上。

一旦
離れよ

ストッパーが、あるかないか。
薄い水色と緑はポインターを走らせる。あれは移動スピードで走らせるのでその情報も要る。つまり乗るとポインターと同じスピードで流されるわけ。
ダメージレールはオーラをまとわせて区別する。プレイヤーは乗れない、という意味（敵は乗れる）。黄色、赤、緑のオーラ。
増やすプロパティは？動き・・レールに速度は必要なのか。
速度は要らないと思う。一定の場所を往復するか、そもそも動かないか、回転、その程度でしょ。要らないと思う。クラスにしてまとめちゃう。
今は実験のために速度与えて楽してるだけ。
だからvやangleSpeedを排除して動きについてはクラスをセットする形に・・
クラスの種類・・セットしない：動かない。static.で、単純往復、いくつかのポイントを順繰りに往復（適当なスパンで）、あるいは
端点を回転させるとか。円の弧となるように回転させる、要はlengthが一定ならいいので・・
弧のtとかについても関数で動かす。おわり。line用、circle用、arc用。

line用：いろいろあり過ぎて・・んー。
事前に全部セットする場合もあればアクティブに生成する場合もあるしそこら辺どうしようみたいな。まあ分けるだけ、だけど。
それについては位置も含めて用意するレールのデータを用意しておいてあとは一定の間隔で出現させるだけ。
たとえばある場所に出現して、一定時間後に消えて、また出現みたいな。
もしくは等間隔で下方に動き続けるとか。等間隔で上方に動き続けるなど。
たとえばこれは、ライフを適切に設定して特定の場所に一定の時間間隔で出現させるだけ。それでいける。
プレイヤーが乗っているとそれを察知して下方に移動するとか（重力加速度が働くかどうかも含めて）。
乗ると動き出す、乗ってるときだけ動く、など。
複数のレールが連動していて片方が下がるともう片方が上がるなど。いろいろ、いろいろ。
回転するなど。あげたらキリがない。これクラス化できるの？？
で・・
arcだったら乗るとtが動いて（時計回りや反時計回り）・・とか。
相手レールの情報を持たせて（というか相手レールを持たせて）それにプレイヤーが乗ってるとどうのこうの、ってやるといいかも。
相手レールというプロパティ（補助）を設けてそれをレール作ってからセットして、ムーブメソッドの方には、
相手レールに乗っているときどうのこうの、とか書けばいいかも。
4つ。
プレイヤーが乗ったら～～（乗ると自由落下するリフト）
プレイヤーが乗ってるときだけ～～（乗ってる間だけ落ちるリフト）
相方にプレイヤーが乗ったら～～（スイッチ）
相方にプレイヤーが乗ってるときだけ～～（シーソーリフト）
で、動きのタイプをそれに応じて用意して、どういうときどうこう、ってやる。
乗るとtrueになるでしょ、で、trueのとき更新するかどうかだよ。更新しなければ1, 3のタイプ、常に更新するなら2, 4のタイプ。
trueのときは更新しない、ですべて表現できる。
シーソーリフトはプレイヤーが乗ってると落ちる、相方にプレイヤーが乗ってると上がる、を両方兼ね備えている。
プレイヤーは常にひとつのレールにしか乗れないので、これらは両立できる。

乗ってない時動いてて乗ると別の動きをするっていうのも面白そう。一定の幅で上下に動いてて乗ると一定の幅で左右に動くとか。
動きのタイプと条件を分離する必要がありそう。それでいける。いける・・んー・・。

あとは消滅条件・・lifeで消すのか、画面外に出たら消すのか・・とか。

増やすプロパティは？？？？？
param
でいいよ。
param:{attribute:属性、stopper:[true, falseなど。trueの場合は縦線で通れないことを明示,reverseがtrueの場合だけ], hasPointer =true/false,
       pointerSpeed:ポインターがあればそのスピード, pointerReverse:ポインターが0から1までカバーしたときに戻るか戻らないかっていう。}
attributeのところをこれで置き換えればOK.
パラメタの取得は関数で書くから問題ないよ。
というか最終的にはステージデータから生成するんでしょ。
getParam(KILL)
getParam(NORMAL, [true, true])
getParam(FORCE, [true, false], true, 4)
getParam(FORCE, [false, false], true, 4, true)
getParam(BIND, [false, true], true, -4, false)
getParam(NORMAL_PASS)
getParam(RAILING_PASS)

ポインタは常に0→1の方向。
getParam(railType, stopper = [false, false], hasPointer = false, pointerSpeed = 1, pointerReverse = false,
         gravityDirection = -PI/2とかPI/2とか, gravityPower = 0.1(大きさ)){}
getParamの引数をオブジェクトにすれば万事解決だな。
{railType:KILLなど,
 stopper:[false, true],
 hasPointer:falseとか,
 pointerSpeed:1とか-2とか,
 pointerReverse:falseだと同じ向き,
 gravityDirection:-PI/2とかPI/2とか,
 gravityPower:0.2とか-0.1とか}
 みたいなのを作ってハメる。

だーーーーーーーーーーーーーーーーーーーーーーーーーーめんどくさいーーーーーーーーーーーーーーーーーーーーーーーーー

なんていうか根本的に見直す必要がありそう。いじったら壊れるってことはフォーマットに不備があるので。フォーマットが見えてない。
今回メソッドがうまくいきすぎちゃってて自分のコードがブラボみたいになっちゃってるのが問題、冷静にならないと。

だいたいdirectionとかspeedってやってるのもデモだからであってこれプレイヤーだとデフォルト0で・・
でも昨日考えたんだけど敵の攻撃がレールに乗っかって襲ってくる場合とか考えるとそれもオブジェクトとして考える必要が出てくるわけで、、
ねぇ？

銀色のレール
重力加速度が方向に応じて働く（接線方向）
接線の計算方法を確立しないと・・
真下に働く感じ
で、左右キーのみで上下キーを受け付けない
坂道のような効果を期待する
白いレールは上下左右自由に動けるけど
このレールは重力に左右される（真下方向！）
ということは真上方向とかも考えられ・・
そうね。白レールでポインター使った方がいい？矢印で。じゃあ銀色にして、矢印を・・
弧や円の場合は真ん中に表示、線分の場合は中心辺りに表示するとか。上とか下向きの矢印。
右向きとか左向きとかで上下キーのみ入力可能にしても面白そう。混乱する・・・・
というかあれ、受け付けないようにする必要もないか・・うん。じゃあ自由な方向で（え？）
方向が変わっても面白そう。ぐるぐる・・矢印の方向に押し付けられる。
下向き固定でシーソーみたいに揺れたりしてもいいね！
重力の大きさが変わってもいいね。
乗ってるときはそうだけど放り出されたら従来通り下向きに働くわけで、これを使わないと到達できない場所とかあったらめちゃ面白そう・・ね？

Playerはレールの特性に応じるけど、・・
ポインターとストッパーについては敵もそれに従う？ああ、いいや、従うもの、従わないもの、いろいろで。ストッパーは影響受けるけど。
ストッパー以外は任意。いろいろ作りたいので。ストッパー、だけ！！

最終的に

hasPointer = true/false; ポインターを有する場合、その大きさと、向きが変わるか否かを設定する感じ。
pointer = {prop:0～1, speed:number, reverse:true/false}
こんな感じでオブジェクトにまとめるといいかも。もしくはもうクラスにする。
class Pointer{
  constructor(_rail, speed, reverse = false){
    this.parent = _rail;
    this.position = 0;
    this.speed = speed;
    this.reverse = reverse;
  }
  progress(){
  }
  getVelocity(){

  }
}
で、接線ベクトルを出すメソッド・・レールについて、そのプロポーションに対し・・長さで1だけずれたところのあれを取る。両側の場合は
0や1をはみ出したら0や1にそろえる。で、異なる2点が得られるので、それで結ぶ感じ。
pointerPosition = 割合(0～1).
pointerSpeed = number;
pointerReverse = true/false;

なお強制移動レールについて移動中はproportionベースで位置を動かすので速度については毎フレーム計算するが位置計算には使わない。
ただ、いつ離脱するのか分からないので一応毎フレーム計算するというだけ。
後にも述べるように速度は2種類の混合とし位置計算はそれに基づく。強制移動レールではtangentの計算で毎フレームの位置を求め、速度は離脱時に適用される。
たとえば水平に動く強制移動のレールで離脱すると水平投射みたいに投げ出されるわけ。端っこで放り出される場合も同様。
これは一つの案だけど、上下左右のキーで、素早く2回押すと押してる間の加速度が倍に・・
ああ、違う、確か最高速が変わるんだっけ。加速は同じだったはず。最高速が速くなるんだ。
いけない。忘れて。まあそういうのあったよね。

stopperFlag = [true/false, true/false]; ストッパーがある場合。

hasAccell = true/false; 加速度を有する場合、常にそれが働くのでそこら辺。
acceleration = number;
accellDirection = number;

calcTangentNormal(proportion){
  proportionにlengthを掛けて1を引いたり足したりしてまたlengthで割って0～1でconstrainして得られる二つの点で
  subしてベクトル作ってnormalize.
}

以上の性質は、通常の敵も効果を受けることとする。こういうのがない場合の動きについては独自性を持たせる・・
たとえばプレイヤーならキー入力でぐりぐり、敵なら一方向に直進するとか一定間隔でジャンプキーの操作が入るとか（一定間隔で向きを変えるとか）。
プレイヤーのいる方向にキーが入力されるとか。
だから敵だとしてもプレイヤーと同じようなあれこれが・・んー。重力に従って落ちるだけとか。弾とかそんな感じ・・
もしくはレールにそもそも乗らないとか。そういうのも適宜用意する。
MovingObjectの方で、invincibleが基本falseで、trueの場合レールを完全に無視して・・とか。弾とかそんな感じの。
まあそうはいっても黄色レール放るだけで普通に攻撃だけど・・

左右キーは優先順位として両方同時押しの場合は右とし、上下キーも同時押しの場合は上とする。左右と上下が同時に押されている場合、
ディレクションの計算はそれらの和とする、つまり8方向を許す。パッド操作なら全方位可能だけど・・
レールに乗ってないときは左右だけが優先されるけれど。で、押している間速度がその方向に上昇し続けるが限界がある。
上下左右すべて入力無しの場合、frictionで速さが小さくなっていき適当な値を下回ると0になる。それとは別に加速度が働く。
通常の空中移動の場合重力加速度による下方移動とそれとは別にキー入力による移動の速度があってそれらの和で決まっているので、
この場合もそれで行こうみたいな。つまり、加速度が働くのは空中にいるときと特定のレールに乗っかってるとき。キー入力で生じる速度と
加速度により生じる速度を分ける。位置の変化はそれらの和によって生じるものとする。キー入力による速度はキー入力している間
増加し続けるが上限があってそれ以降は和を取った後大きさを補正する感じ。レールの乗り移りでこれは変化しないとする。
計算はまだね。
加速度により生じる速度はレールに乗るとき一旦0にリセットされるがレールから外れるときは継続する。これにも上限が定められている。
両方に上限を決めるのでトータルの上限は敢えて設定しない。
空中では上下キーによる操作は無効。
frictionについて。左右いずれのキー入力もない場合にvelocityのx成分がfrictionで小さくなっていく（一定以下になったら0とする）。
上下についても同様。だからレールから飛び出した後、上下方向の入力による速度は一気に0に近づく感じ。

合計としてそのフレームの速度が得られたら、レールに乗ってなければ確定、乗ってる場合は接線方向を計算してその分目減りする感じで。
つまり接線方向になる。
それを別々に計算して、大きさでバリデーションかけて必要なら下げる、こうしてトータルが決まる感じ。
トータルが決まったらレールの場合は大きさだけ採用して位置をいじる。空中の場合は普通に足すだけ。

ここら辺のメソッドを共通で用意しつつ・・ジャンプ？？
レールに乗ってるとき・・空中ジャンプは応相談。一応レールに乗ってるときだけジャンプできるように。
ジャンプのフラグが立っていたら
加速度側の速度のy成分に-6とか-7みたいなのを足す。足してからフラグを消す。
もしくはフラグの維持を行うことで、押している長さによるジャンプの高さの調整みたいなことをやるかもしれないけど。フラグの延長。
キー入力はフラグが消えているときにできる。だからフラグを維持するか否かっていうのをきちんと考えましょう。
と同時にレールから離脱する。つまりジャンプした後は必ずレールから外れているし、多段ジャンプするとしてもレールには乗っていない。
離脱できないレールを除いては常に可能。離脱により速度は変化しないため、単純に加速度サイドの速度のy成分への足し算（というか引き算？）になる。
たとえばオーソドックスな白レールの場合加速度サイドは0だから普通の、いわゆる普通のジャンプになる。
これもメソッドで分けて敵にもある程度使えるようにしたら面白いかも。引数をジャンプの高さにするとか・・

------ジャンプは足し算やめて固定にしよう。accellを垂直上方にする。それと別にキー入力があって左右へのジャンプを実現する形。------
（そうしないと加速度レールで加速度が生じてるときめんどくさいことになるから）

ジャンプとは別に、離脱、というのがある。これは単にレールから外れるもの。もちろん離脱可能な場合・・だけど。
これはもう単純に離脱するだけ。
今まではレールが消えた場合の速度を前フレームの位置とか使って計算してたけど、今回の実装では速度は常に計算するので・・
ああそうね。
強制移動レールの場合、乗るとき加速度サイドの速度は0となり、入力サイドの速度はポインターの速さと接線で決まる。
ポインターの値が正なら-d~0~+d, 負なら+d~0~-dで取る感じ。その方向と、ポインターのスカラー値で決定する。
だから離脱時の速度はpreviousとか使わずに普通に速度をそのまま使っていい。前フレームは、見なくていい。動いてない時は0だから。
離脱は、だからあれ、よくある下ボタンで下に降りるやつの実装。とりあえずシフトキー。

エンターキーで攻撃、は、さすがにまだ無理。スペースキーでジャンプ、それで勘弁して。

エンターキーによる攻撃で考えてるのは、レールに乗ってるときは押すたびに周囲攻撃、押してる間周囲にオーラをまとう、
一定時間押し続けてから離すと8方向に射程の短い弾を撃つ。
乗ってない時は押すたびに前方に射程ある程度長い感じの弾を撃つ、それでいいよね。とりあえず。
威力や弾の大きさがパワーアップしたら面白そうだけど
未来の話。

bind = false; // trueだと離脱不可能。
damageFlag = NONE/ALL/ON_RAIL/OFF_RAIL; ダメージレールの場合、そのタイプについて。NONEはダメージレールではないという意味です。
calcTangentVector(){} 接線方向の単位ベクトルの計算。向きは問題ない。矢印キー入力時の移動方向とかに使う。

レールのムーブは今考えると頭がパンクするので、
とりあえず往復移動だけにするか。それでプレイヤー操作できるようにして、各種仕様のレールを用意して、きちんと動くか確かめましょう。
テストに成功したら・・動きについては、グローバルの関数をいくつも用意しよかな。moveを返す感じの関数をいくつか。

lifeについて。
同じレールの再利用をするケースとかも考えたい。一定時間後に同じ場所に同じ形で復活するの。カウントやフラグをリセットすれば済む話。
trashという配列を用意してsleepCountが正のものは排除した後でそこに入れ、updateでカウントを進めて0になったらsleepCountを
元に戻しつつカウントやフラグをもろもろリセットして元の配列に戻す。これでループ完成。sleepCountが0のものは使い捨て。
lifeはInfinityが基本とする。

// ------------------------------------------------------------------------------------------------------------------------ //

じゃあ仕様変更第一段階まとめするよ。

レール側：
attributeやめてparamにする。で、内容は
{
 railType KILL_RとかNORMAL_Rとかそういうの,
 stopper 指定がなければ[false, false]にする。reverseがtrueの場合だけ。しきいがあるかないか,
 pointerSpeed 指定がなければポインターを用意しない。ポインターの移動スピード（絶対スピード）,
 pointerReverse pointerが端っこに達したときに向きを変えるかどうか。,
 acceleration 指定がなければundefinedにする。スカラー値。ベクトルにするのは別処理。
}
あっ・・・アクセルはベクトルや・・ね・・んー。そうね・・うん。斜めで鉛直下方とかあるし・・

これにより設定する新しいプロパティ
pointer. 指定がなければundefinedで、あればクラスでインスタンスを作る。
stopper. デフォは[false, false]で、端っこで抜けるかどうかの処理。
forceとbind. forceはオブジェクトを強制的に移動させるかどうか。bindは離脱できなくさせるかどうか。この2つ。デフォはいずれもfalse.
damageFlag:ダメージレールかどうかがrailTypeでわかるので・・そうでなければNONEで、ALL, ON_RAIL, OFF_RAILの4パターン。
ダメージ受けない（乗る）、常に即死、レールに乗ってるときだけやられる、レールに乗ってない時だけやられる。うん。

lifeはデフォルトInfinityでsleepCountもデフォルト0で。引数に入れず、設定する場合は特殊なので、メソッドで設定することにする。
Infinity量産するのもなんかね。あれだし。
setLife(lifeCount, sleepCount){~~~~~}
で、trashを用意してlifeCountに達したら放り込んでsleepCountまでproperFrameCountを増やし続けてsleepCountに達したら出して・・
もろもろリセットして復活させる。だからproperFrameCountは常に増やせないといけないのね。
kill()のところに「sleepCountが正の場合はproperFrameCountを0にする」と記述し、trash内では「sleepCheck()」を実行させる。
sleepCheck()ではproperFrameCountを増やし続けsleepCountに達したらもろもろのリセット処理reset()を実行させる。で、その際に
aliveがtrueになる。aliveがtrueのレールはtrashから排除され元のrailsに戻る。そういう仕組みね。

calcTangent()について。
proportionに対して計算する。proportion * length ± 1をproportionで割る。で、[0, 1]でconstrainして、ふたつ取る。
それらは異なる点を与えるので結んで正規化して単位ベクトルにするだけ。

オブジェクト側：
プロパティについてはまあ、レール無視する敵とか敵の弾とかだったらavoidRailとかフラグ作ってこれがtrueの場合はレールに乗せない、
まあいいや。プロパティ。
avoidRail:デフォルトfalse.これがtrueのとかはクラス派生でいじる。レールに乗るかどうかってやつ。
manualVelocity, accellVelocity.
manualVelocityは操作により生じる加速度でレールに乗る前、乗った後での変化はなし。accellVelocityはレールに乗るたびにリセット。
これらを別々に更新してレール補正して大きさで抑えてその値を次も使う。
で、updateとdraw.

updateとdrawに分けて考える。
update側：
まずレールに乗ってるかどうかで処理を分ける。moveをプロパティ化する。
offRailMoveとonRailMoveをプロパティにしてPlayerの場合に特別なそれを設定してプレイヤーを動かす。
レールに乗ってない時はoffRailMoveで乗ってるときはonRailMoveを実行するっていうのをupdateの大枠にして。
あとcheckも。
PlayerのoffRailMoveの流れ。
左右のキー入力を見てあれば右優先で加速（大きさの上限あり）、無ければfrictionで減速
上下のキー入力は無視。frictionで減速
重力加速度鉛直下向きの補正をaccellに加える。大きさの上限あり。
合計に従って位置補正。
PlayerのonRailMoveの流れ。
forceがtrueの場合：pointerに従って位置補正、accellVelocityはすでに0にしてある。manualだけいじる。とはいえ接線調べて
常に用意しておくだけだけど。あー、要らないか？離脱時にレール情報から受け取ればいいか。うん。
やめた。位置補正だけして離脱時にforceがtrueだったらpointerの値と接線情報から速度を設定することにしよう。accellは常に0で飛び出すときも0とする。
円軌道の場合とかいちいち毎フレーム計算するのもあれだし（不要だし）。
って思ったけどやっぱ毎フレーム計算しよう・・どっちにしろ同じだ・・接線情報とpointerの値からmanualの速度は随時計算する。
forceがfalseの場合：上下左右のキー入力に従って加速なりfrictionなりしてmanualを設定。
accellの方はaccelerationがundefinedでなければその方向で足す感じ。これはスカラー値。接線ベクトルを計算してできる加速度を足す。
ごめんなさいベクトルですこれ。で、普通に足す・・で、接線で射影取って大きさ補正。
それらの速度について射影を取り、大きさで抑えて、それらの値を次のフレームとか離脱時に使うんだけど、
位置更新の時はスカラーだけ取り出してproportion更新で位置を更新する。まあ、当然・・はみ出したらえらいことになるので。
で、その更新の際に、reverseがfalseなら元に戻すのよ。0より小さくなったら1側、1より大きくなったら0側。
reverseがtrueだとして、それで0より小さいか1より大きい時、ストッパーを見て、trueならconstrainするけど、falseなら離脱処理を行う。
PlayerのCheckの流れ。
画面外に出た時にkill()みたいのをここに書く。
Player以外のoffRailMoveの流れ。
Playerと違ってばかみたいに直進してもいいし勝手にふよふよランダムウォークしてもいいしPlayerの方に向かってきてもいいし
いろいろ。円軌道まわってもいいし。レール無視していいので。
まあレールの上を回るってすれば行動になるけど。んー。
Player以外のonRailMoveの流れ。
そもそもレールに乗るかどうかってのがあって・・まあ乗るけど。乗ってからは基本一緒、インプットのところをたとえば右オンリーとか左オンリーとか
プレイヤーのいる方向に上下左右キーを入力するとかそこら辺。いない時は動かないとか。同じレールに乗ってるときだけ動くとか、いろいろ。
千差万別。
Player以外のCheckの流れ。
画面外に出た時にkill(),もしくはライフがあってproperFrameCountがそこに達すると消えるとか。
あとは周期的にattackとか？もしくは確率判定でattack, それらのタイミングでプレイヤーに向かってショット、以下略。
update(){
  onRailMove/offRailMove, check, attack
}
ジャンプと離脱
ジャンプ：
レールがbind:falseのときに可能で、accellを鉛直上向きの速度に固定する。左右は入力時のものが使えるから左右ジャンプが可能。
上だったら高いジャンプもできるってわけね。逆に下だと低いジャンプになったり。これでしかたどり着けない場所を作ったりもできるのでうまく作らないと・・
離脱：
やはりレールがbind:falseの時に可能、これはmanual,accellいずれの速度もそのまま使ってレールから外れるだけ。
自由落下や水平投射みたいになる。以降はoffRailMoveに従う。
トランジション（レールからレールに乗り移る場合）：
これは離脱ではないので・・レールに乗る処理なので、普通にaccellを0にしてmanualは継続、いっしょ。普通に乗るときといっしょでいい。

第二段階はまた別の機会に考えるということで・・

あー、そうね。上向きの円弧（下が開いている）で下向き重力ではしっこopenだったら面白いわね（両側から落ちていく）。

// ------------------------------------------------------------------------------------------------------------------------ //

ダメージレールはオーラをまとわせて区別したい。動きを持たせて分かりやすくしたい。たとえばstrokeを太くして範囲をまわすとか・・
20%くらいの範囲でしゅいーんしゅいーんみたいな（？？）

描画部分をどういじるか。
ストッパーがある場合は端っこに縦線（垂直線）。短い。太さは一緒で長さは固定。端っこで接線を毎フレーム計算して・・まあ、そういう感じで。
ポインターがある場合はそれを走らせる。同じ感じの線を。位置はポインターの方で計算してくれる。
加速度がある場合は真ん中あたりに正方形と三角形を組み合わせてできる白い矢印をふよふよさせて。長さは同じでいいから。めんど・・

一応、レールの方修正終わりました・・
キャパシティとかは廃止ですね。とりあえずいくつか作ってみてそれで実験とかする感じなので。
明日以降objectの方いじりますけどとりあえずproperFrameCountに統一するところからですね・・

いろいろ考えたけどストッパーだけでいいか。たとえばまっすぐ進むとかもありだろうし。
ストッパーも要らないかな・・（緑とか赤のノコノコを想像しながら）
じゃあもう完全にレールに乗るかどうかだけって話になるわね。どんどん変化していく。

reactionってプレイヤーだけがダメージレールでダメージ受けるのに普通にやばいやんね・・これね、
プレイヤーにブリンク用意して・・んー。そうそう、即死やめて反射にしよう、ダメージ受けて反射、そういう案もあったんだけど。
まあブリンクとかは用意するけど。
HPとかは、これもオブジェクトによっては、ないからなー・・ギミックとか。たとえば円レールをぐるぐる回るだけとか。そういうのも
想定、マリオでバブルって倒せないけどああいうのイメージしてる。はい、次。
reactionは個別。

すげぇめんどくさいいいいいい
めんどくさいいいいいいいいいう

あれ・・何からやればいいのか分かんない・・・あれ？？？？
やっぱマニュアルスピードは
