どうしよっかな。
白：当たるとゲームオーバー
残機数が減って最初からです。0になったらおわりです。
消えるとき、線を引いて出現させるときなどパーティクル実装おねがいです。
ボールはオレンジで引く線は水色でいきます。
当たると
円形のレールも用意して勝手に乗っちゃうの。そういうのもギミックとして追加する。

薄い緑：通常のレール。
白：やられる
赤：レールに乗ってなければやられない
青：レールに乗っていればやられない
黄色：普通に乗れるが乗ってる間だけスピードアップ（ファクターをいじる）
茶色：普通に乗れるが乗ってる間だけスピードダウン（ファクターをいじる）
濃い緑：当たると反射する、何回か反射すると消える
濃い目の水色：加速していないとやられる（加速していればOKでスピードは無関係）

アクションにしてもいいかなって思ったの。ボタンでジャンプして離脱するみたいな。重力実装して。
レールによって、十字キーで動けるか、または強制的に動かされるか。
往復する場合もあるし、端っこに来た時の挙動とかもいろいろ、単に折り返すか、そのまま飛び出すかみたいな。
方向を変えるギミックとか用意すれば・・で、ステージをくっつけたり。スクロールでもいいけど。

三角や四角形あってもいいけどとりあえず円と直線だけでいろいろできそうなのよね。

タイプ0:通過するとやられるやつ。
タイプ1:上に乗れる。ジャンプで離脱。シフトで離脱、ジャンプボタンと左右キーでジャンプ、そこら辺は一緒。
       端っこについては外れる場合と外れない場合がある。
タイプ2:一定の方向に流される。はしっこで強制的に外れる。
タイプ3:行ったり来たりする。どっちに流されるかはポインター（たとえば直交する線分）を見ると分かる感じ。
はしっこでは方向が逆転するまで止まらされる（ジャンプなどでの離脱は可能）。
で、サークルタイプのやつとか。一定時間ごとに向きが変わったりすると面白いかも。
あとは、レールに乗ってるときだけやられるとか、乗ってない時だけやられるとか。
逆らってジャンプで進まないといけないところとかありそうで面白そうね（？？）
外れることができないレールとかもありそうだな・・・タイプ4とか？
レールから外れるときは強制的に速度が固定される。そこら辺は今の仕様そのままでいいと思う。
時間をおいてその間は乗れないのとかも。

十字キーでどっちに進むか？接線情報を設けてそれと上下左右で取って直交してなければその方向に行く感じ。あんま小さければ動けないようにするけど。
赤レール：通過するとやられる
白レール：ごく普通のレール。縦、横、斜め。十字キーで移動。ジャンプで離脱、シフトで直接離脱、その場合は普通に速度計算（previous使って）。
端っこで離脱するかどうかは直交する線分で明示。それがある場合は離脱できない感じ。
青レール：ポインターが走っていて、その方向に強制的に流される。十字キー操作は無効。離脱は普通に可能。
ポインターの向きが変わることがありその場合は行ったり来たりする。端っこで（以下略）。
黄色レール：外れることができない。ずっと動きっぱなし。端っこに来ないと離脱できない。強制移動ね。だから端っこは解放されている（でないとやばい）。

レールに乗ってる間は緑色のオーラみたいなのが出るようにして。。通常時はピンクのオーラでいい？分かりやすいでしょその方が。
緑レール：レールに乗ってる状態で通過すればやられない。レールに乗ってない状態で通過するとアウト。
ピンクレール：逆にレールに乗ってる状態で通過するとアウト。だから通過するにはレールを外れないといけない。
レールではないな。まあいいや。（？）
例えばだけど空中にアイテムあったらジャンプとかしないと取れないから外れざるを得ないみたいなのを想定してる。緑レールはそんな感じ。
逆にピンクレールは強制移動とかあったらジャンプして外れないとやばいみたいなのを想定してる。ステージ作るの大変そうね・・。
それらとは別に当たったらやられるオブジェクトを走らせるのも面白いかも。勝手に折り返したりする。たとえば白レールの上を走らせて邪魔したりとか。
透明レール：敵を動かすためだけに用意されたレール。プレイヤーが触れても何も起こらない。
点滅してダメージ受けるだけにした方がいいかもだね・・赤レールは即死でいいよ。え？
攻撃ができないので普通にステージクリア形式になるのかなぁ（知らんけど）。

なんかひとつステージ作ってみてよ。雑に。
スクロール久しぶりだから忘れてる？描画をおさまるものに限るだけよ。難しくない。
背景はモノクロにするけどいろいろパターン欲しい。チェック、トライアングル、あとまあ、白黒の青海波とかいろいろ。GLSLのが描きやすいかも。
真っ黒でいいか、とりあえず。

アイデアばっか書いてても進まないのでいい加減実装しようかな。とりあえずオブジェクトの他にプレイヤー・・
それはねぇ、継承でENEMYとPLAYERした方がいいと思うのよね。

そういえばlifeとかあるけどこれデフォルトで無限みたいになる？消えても面白いよね。
一定時間たつと消える白いレール、また復活、そういうのを乗り継いでジャンプで渡っていくみたいなの想像してた。
それが上下するとか。

色々変更
白レール：ごく普通のレール。乗っている間自由に十字キーで移動可能。離脱にはボタンを使う。
薄い水色レール：ポインターが走っててそれに従ってproportionを動かされる。離脱は普通に可能。
薄い緑レール：強制的に移動させられる。ゆえに一方通行で端っこで投げ出される
共に端っこにストッパーがあったりなかったりする。
常に赤いオーラをまとっている。レールに乗っていると青いオーラになる。
黄色レール：通過すると一発アウト
赤レール：すっぴんの状態で通過できるがレールに乗った状態だと一発アウト
青レール：レールに乗った状態で通過できるがすっぴんの状態だと一発アウト

敵が乗った場合は従来通り勝手に往復する。すべてのレールが対象である。ムーブレール、ダメージレール問わず普通に動くし大きければ当たり判定も大きい。
プレーヤーはブリンクしてその間は無敵。ラインに関しては一発アウト。でないとギミックの意味がないので。

普通に今のままでいい。オーラは消す。
パーティクルを放出してはじけ飛ぶ。60フレーム後に残機があればセーブポイントから再開、無ければゲームオーバー判定。
そこら辺はぼちぼちって感じですかね・・

あと多角形のレールはやめようかなと。線分組み合わせればいいので。

はい。
ストッパー、ポインター、ダメージ情報。この辺。を、attribute（今使ってない情報）で決める。
ダメージレールかムーブレールか、さらに・・って感じ。
stopperとかpointerはいろいろなので作ってから設定する方がいいかもしれない。constructorに全部放り込むより。

敵に関しては従来通りでいいや。今やってる、この通りで。そんで、こっちだけいろいろ、みたいな。
reverseがtrueでかつ端っこに来た時に、敵によっては放り出されて自由落下する、もしくはそのまま往復、みたいにする。
さらにそれとは別に勝手な動きをする敵を用意する。以上。

攻撃・・今考えてるのは周囲攻撃。オーラが広がって当たった敵がスリップダメージ、的な感じの。
レールに乗ってるときは青いオーラが広がって周囲攻撃、乗ってない時は赤い弾丸みたいのが最後に入力した左右キーの方向に発射される。
パワーアップでレールに乗ってても遠隔、あるいは乗ってなくても近接、みたいになったり？書けるだけ書いちゃう。

しかたない
つぶやきなんちゃらが猛威を振るってる以上、ここまでやらないとクソプログラム認定されちゃうわけだから。
ここまでやらないと。結局0か、1かなんだよ。
一生懸命つくってるものをクソ扱いされたくない。これ以上。

一旦
離れよ

ストッパーが、あるかないか。
薄い水色と緑はポインターを走らせる。あれは移動スピードで走らせるのでその情報も要る。つまり乗るとポインターと同じスピードで流されるわけ。
ダメージレールはオーラをまとわせて区別する。プレイヤーは乗れない、という意味（敵は乗れる）。黄色、赤、緑のオーラ。
増やすプロパティは？動き・・レールに速度は必要なのか。
速度は要らないと思う。一定の場所を往復するか、そもそも動かないか、回転、その程度でしょ。要らないと思う。クラスにしてまとめちゃう。
今は実験のために速度与えて楽してるだけ。
だからvやangleSpeedを排除して動きについてはクラスをセットする形に・・
クラスの種類・・セットしない：動かない。static.で、単純往復、いくつかのポイントを順繰りに往復（適当なスパンで）、あるいは
端点を回転させるとか。円の弧となるように回転させる、要はlengthが一定ならいいので・・
弧のtとかについても関数で動かす。おわり。line用、circle用、arc用。

line用：いろいろあり過ぎて・・んー。
事前に全部セットする場合もあればアクティブに生成する場合もあるしそこら辺どうしようみたいな。まあ分けるだけ、だけど。
それについては位置も含めて用意するレールのデータを用意しておいてあとは一定の間隔で出現させるだけ。
たとえばある場所に出現して、一定時間後に消えて、また出現みたいな。
もしくは等間隔で下方に動き続けるとか。等間隔で上方に動き続けるなど。
たとえばこれは、ライフを適切に設定して特定の場所に一定の時間間隔で出現させるだけ。それでいける。
プレイヤーが乗っているとそれを察知して下方に移動するとか（重力加速度が働くかどうかも含めて）。
乗ると動き出す、乗ってるときだけ動く、など。
複数のレールが連動していて片方が下がるともう片方が上がるなど。いろいろ、いろいろ。
回転するなど。あげたらキリがない。これクラス化できるの？？
で・・
arcだったら乗るとtが動いて（時計回りや反時計回り）・・とか。
相手レールの情報を持たせて（というか相手レールを持たせて）それにプレイヤーが乗ってるとどうのこうの、ってやるといいかも。
相手レールというプロパティ（補助）を設けてそれをレール作ってからセットして、ムーブメソッドの方には、
相手レールに乗っているときどうのこうの、とか書けばいいかも。
4つ。
プレイヤーが乗ったら～～（乗ると自由落下するリフト）
プレイヤーが乗ってるときだけ～～（乗ってる間だけ落ちるリフト）
相方にプレイヤーが乗ったら～～（スイッチ）
相方にプレイヤーが乗ってるときだけ～～（シーソーリフト）
で、動きのタイプをそれに応じて用意して、どういうときどうこう、ってやる。
乗るとtrueになるでしょ、で、trueのとき更新するかどうかだよ。更新しなければ1, 3のタイプ、常に更新するなら2, 4のタイプ。
trueのときは更新しない、ですべて表現できる。
シーソーリフトはプレイヤーが乗ってると落ちる、相方にプレイヤーが乗ってると上がる、を両方兼ね備えている。
プレイヤーは常にひとつのレールにしか乗れないので、これらは両立できる。

乗ってない時動いてて乗ると別の動きをするっていうのも面白そう。一定の幅で上下に動いてて乗ると一定の幅で左右に動くとか。
動きのタイプと条件を分離する必要がありそう。それでいける。いける・・んー・・。

あとは消滅条件・・lifeで消すのか、画面外に出たら消すのか・・とか。

増やすプロパティは？？？？？
param
でいいよ。
param:{attribute:属性、stopper:[true, falseなど。trueの場合は縦線で通れないことを明示,reverseがtrueの場合だけ], hasPointer =true/false,
       pointerSpeed:ポインターがあればそのスピード, pointerReverse:ポインターが0から1までカバーしたときに戻るか戻らないかっていう。}
attributeのところをこれで置き換えればOK.
パラメタの取得は関数で書くから問題ないよ。
というか最終的にはステージデータから生成するんでしょ。
getParam(KILL)
getParam(NORMAL, [true, true])
getParam(FORCE, [true, false], true, 4)
getParam(FORCE, [false, false], true, 4, true)
getParam(BIND, [false, true], true, -4, false)
getParam(NORMAL_PASS)
getParam(RAILING_PASS)

ポインタは常に0→1の方向。
getParam(railType, stopper = [false, false], hasPointer = false, pointerSpeed = 1, pointerReverse = false,
         gravityDirection = -PI/2とかPI/2とか, gravityPower = 0.1(大きさ)){}
getParamの引数をオブジェクトにすれば万事解決だな。
{railType:KILLなど,
 stopper:[false, true],
 hasPointer:falseとか,
 pointerSpeed:1とか-2とか,
 pointerReverse:falseだと同じ向き,
 gravityDirection:-PI/2とかPI/2とか,
 gravityPower:0.2とか-0.1とか}
 みたいなのを作ってハメる。

だーーーーーーーーーーーーーーーーーーーーーーーーーーめんどくさいーーーーーーーーーーーーーーーーーーーーーーーーー

なんていうか根本的に見直す必要がありそう。いじったら壊れるってことはフォーマットに不備があるので。フォーマットが見えてない。
今回メソッドがうまくいきすぎちゃってて自分のコードがブラボみたいになっちゃってるのが問題、冷静にならないと。

だいたいdirectionとかspeedってやってるのもデモだからであってこれプレイヤーだとデフォルト0で・・
でも昨日考えたんだけど敵の攻撃がレールに乗っかって襲ってくる場合とか考えるとそれもオブジェクトとして考える必要が出てくるわけで、、
ねぇ？

銀色のレール
重力加速度が方向に応じて働く（接線方向）
接線の計算方法を確立しないと・・
真下に働く感じ
で、左右キーのみで上下キーを受け付けない
坂道のような効果を期待する
白いレールは上下左右自由に動けるけど
このレールは重力に左右される（真下方向！）
ということは真上方向とかも考えられ・・
そうね。白レールでポインター使った方がいい？矢印で。じゃあ銀色にして、矢印を・・
弧や円の場合は真ん中に表示、線分の場合は中心辺りに表示するとか。上とか下向きの矢印。
右向きとか左向きとかで上下キーのみ入力可能にしても面白そう。混乱する・・・・
というかあれ、受け付けないようにする必要もないか・・うん。じゃあ自由な方向で（え？）
方向が変わっても面白そう。ぐるぐる・・矢印の方向に押し付けられる。
下向き固定でシーソーみたいに揺れたりしてもいいね！
重力の大きさが変わってもいいね。
乗ってるときはそうだけど放り出されたら従来通り下向きに働くわけで、これを使わないと到達できない場所とかあったらめちゃ面白そう・・ね？

Playerはレールの特性に応じるけど、・・
ポインターとストッパーについては敵もそれに従う？ああ、いいや、従うもの、従わないもの、いろいろで。ストッパーは影響受けるけど。
ストッパー以外は任意。いろいろ作りたいので。ストッパー、だけ！！

最終的に

hasPointer = true/false; ポインターを有する場合、その大きさと、向きが変わるか否かを設定する感じ。
pointer = {prop:0～1, speed:number, reverse:true/false}
こんな感じでオブジェクトにまとめるといいかも。もしくはもうクラスにする。
class Pointer{
  constructor(_rail, speed, reverse = false){
    this.parent = _rail;
    this.position = 0;
    this.speed = speed;
    this.reverse = reverse;
  }
  progress(){
  }
  getVelocity(){

  }
}
で、接線ベクトルを出すメソッド・・レールについて、そのプロポーションに対し・・長さで1だけずれたところのあれを取る。両側の場合は
0や1をはみ出したら0や1にそろえる。で、異なる2点が得られるので、それで結ぶ感じ。
pointerPosition = 割合(0～1).
pointerSpeed = number;
pointerReverse = true/false;

なお強制移動レールについて移動中はproportionベースで位置を動かすので速度については毎フレーム計算するが位置計算には使わない。
ただ、いつ離脱するのか分からないので一応毎フレーム計算するというだけ。
後にも述べるように速度は2種類の混合とし位置計算はそれに基づく。強制移動レールではtangentの計算で毎フレームの位置を求め、速度は離脱時に適用される。
たとえば水平に動く強制移動のレールで離脱すると水平投射みたいに投げ出されるわけ。端っこで放り出される場合も同様。
これは一つの案だけど、上下左右のキーで、素早く2回押すと押してる間の加速度が倍に・・
ああ、違う、確か最高速が変わるんだっけ。加速は同じだったはず。最高速が速くなるんだ。
いけない。忘れて。まあそういうのあったよね。

stopperFlag = [true/false, true/false]; ストッパーがある場合。

hasAccell = true/false; 加速度を有する場合、常にそれが働くのでそこら辺。
acceleration = number;
accellDirection = number;

calcTangentNormal(proportion){
  proportionにlengthを掛けて1を引いたり足したりしてまたlengthで割って0～1でconstrainして得られる二つの点で
  subしてベクトル作ってnormalize.
}

以上の性質は、通常の敵も効果を受けることとする。こういうのがない場合の動きについては独自性を持たせる・・
たとえばプレイヤーならキー入力でぐりぐり、敵なら一方向に直進するとか一定間隔でジャンプキーの操作が入るとか（一定間隔で向きを変えるとか）。
プレイヤーのいる方向にキーが入力されるとか。
だから敵だとしてもプレイヤーと同じようなあれこれが・・んー。重力に従って落ちるだけとか。弾とかそんな感じ・・
もしくはレールにそもそも乗らないとか。そういうのも適宜用意する。
MovingObjectの方で、invincibleが基本falseで、trueの場合レールを完全に無視して・・とか。弾とかそんな感じの。
まあそうはいっても黄色レール放るだけで普通に攻撃だけど・・

左右キーは優先順位として両方同時押しの場合は右とし、上下キーも同時押しの場合は上とする。左右と上下が同時に押されている場合、
ディレクションの計算はそれらの和とする、つまり8方向を許す。パッド操作なら全方位可能だけど・・
レールに乗ってないときは左右だけが優先されるけれど。で、押している間速度がその方向に上昇し続けるが限界がある。
上下左右すべて入力無しの場合、frictionで速さが小さくなっていき適当な値を下回ると0になる。それとは別に加速度が働く。
通常の空中移動の場合重力加速度による下方移動とそれとは別にキー入力による移動の速度があってそれらの和で決まっているので、
この場合もそれで行こうみたいな。つまり、加速度が働くのは空中にいるときと特定のレールに乗っかってるとき。キー入力で生じる速度と
加速度により生じる速度を分ける。位置の変化はそれらの和によって生じるものとする。キー入力による速度はキー入力している間
増加し続けるが上限があってそれ以降は和を取った後大きさを補正する感じ。レールの乗り移りでこれは変化しないとする。
計算はまだね。
加速度により生じる速度はレールに乗るとき一旦0にリセットされるがレールから外れるときは継続する。これにも上限が定められている。
両方に上限を決めるのでトータルの上限は敢えて設定しない。
空中では上下キーによる操作は無効。
frictionについて。左右いずれのキー入力もない場合にvelocityのx成分がfrictionで小さくなっていく（一定以下になったら0とする）。
上下についても同様。だからレールから飛び出した後、上下方向の入力による速度は一気に0に近づく感じ。

合計としてそのフレームの速度が得られたら、レールに乗ってなければ確定、乗ってる場合は接線方向を計算してその分目減りする感じで。
つまり接線方向になる。
それを別々に計算して、大きさでバリデーションかけて必要なら下げる、こうしてトータルが決まる感じ。
トータルが決まったらレールの場合は大きさだけ採用して位置をいじる。空中の場合は普通に足すだけ。

ここら辺のメソッドを共通で用意しつつ・・ジャンプ？？
レールに乗ってるとき・・空中ジャンプは応相談。一応レールに乗ってるときだけジャンプできるように。
ジャンプのフラグが立っていたら
加速度側の速度のy成分に-6とか-7みたいなのを足す。足してからフラグを消す。
もしくはフラグの維持を行うことで、押している長さによるジャンプの高さの調整みたいなことをやるかもしれないけど。フラグの延長。
キー入力はフラグが消えているときにできる。だからフラグを維持するか否かっていうのをきちんと考えましょう。
と同時にレールから離脱する。つまりジャンプした後は必ずレールから外れているし、多段ジャンプするとしてもレールには乗っていない。
離脱できないレールを除いては常に可能。離脱により速度は変化しないため、単純に加速度サイドの速度のy成分への足し算（というか引き算？）になる。
たとえばオーソドックスな白レールの場合加速度サイドは0だから普通の、いわゆる普通のジャンプになる。
これもメソッドで分けて敵にもある程度使えるようにしたら面白いかも。引数をジャンプの高さにするとか・・

------ジャンプは足し算やめて固定にしよう。accellを垂直上方にする。それと別にキー入力があって左右へのジャンプを実現する形。------
（そうしないと加速度レールで加速度が生じてるときめんどくさいことになるから）

ジャンプとは別に、離脱、というのがある。これは単にレールから外れるもの。もちろん離脱可能な場合・・だけど。
これはもう単純に離脱するだけ。
今まではレールが消えた場合の速度を前フレームの位置とか使って計算してたけど、今回の実装では速度は常に計算するので・・
ああそうね。
強制移動レールの場合、乗るとき加速度サイドの速度は0となり、入力サイドの速度はポインターの速さと接線で決まる。
ポインターの値が正なら-d~0~+d, 負なら+d~0~-dで取る感じ。その方向と、ポインターのスカラー値で決定する。
だから離脱時の速度はpreviousとか使わずに普通に速度をそのまま使っていい。前フレームは、見なくていい。動いてない時は0だから。
離脱は、だからあれ、よくある下ボタンで下に降りるやつの実装。とりあえずシフトキー。

エンターキーで攻撃、は、さすがにまだ無理。スペースキーでジャンプ、それで勘弁して。

エンターキーによる攻撃で考えてるのは、レールに乗ってるときは押すたびに周囲攻撃、押してる間周囲にオーラをまとう、
一定時間押し続けてから離すと8方向に射程の短い弾を撃つ。
乗ってない時は押すたびに前方に射程ある程度長い感じの弾を撃つ、それでいいよね。とりあえず。
威力や弾の大きさがパワーアップしたら面白そうだけど
未来の話。

bind = false; // trueだと離脱不可能。
damageFlag = NONE/ALL/ON_RAIL/OFF_RAIL; ダメージレールの場合、そのタイプについて。NONEはダメージレールではないという意味です。
calcTangentVector(){} 接線方向の単位ベクトルの計算。向きは問題ない。矢印キー入力時の移動方向とかに使う。

レールのムーブは今考えると頭がパンクするので、
とりあえず往復移動だけにするか。それでプレイヤー操作できるようにして、各種仕様のレールを用意して、きちんと動くか確かめましょう。
テストに成功したら・・動きについては、グローバルの関数をいくつも用意しよかな。moveを返す感じの関数をいくつか。

lifeについて。
同じレールの再利用をするケースとかも考えたい。一定時間後に同じ場所に同じ形で復活するの。カウントやフラグをリセットすれば済む話。
trashという配列を用意してsleepCountが正のものは排除した後でそこに入れ、updateでカウントを進めて0になったらsleepCountを
元に戻しつつカウントやフラグをもろもろリセットして元の配列に戻す。これでループ完成。sleepCountが0のものは使い捨て。
lifeはInfinityが基本とする。

// ------------------------------------------------------------------------------------------------------------------------ //

じゃあ仕様変更第一段階まとめするよ。

レール側：
attributeやめてparamにする。で、内容は
{
 railType KILL_RとかNORMAL_Rとかそういうの,
 stopper 指定がなければ[false, false]にする。reverseがtrueの場合だけ。しきいがあるかないか,
 pointerSpeed 指定がなければポインターを用意しない。ポインターの移動スピード（絶対スピード）,
 pointerReverse pointerが端っこに達したときに向きを変えるかどうか。,
 acceleration 指定がなければundefinedにする。スカラー値。ベクトルにするのは別処理。
}
あっ・・・アクセルはベクトルや・・ね・・んー。そうね・・うん。斜めで鉛直下方とかあるし・・

これにより設定する新しいプロパティ
pointer. 指定がなければundefinedで、あればクラスでインスタンスを作る。
stopper. デフォは[false, false]で、端っこで抜けるかどうかの処理。
forceとbind. forceはオブジェクトを強制的に移動させるかどうか。bindは離脱できなくさせるかどうか。この2つ。デフォはいずれもfalse.
damageFlag:ダメージレールかどうかがrailTypeでわかるので・・そうでなければNONEで、ALL, ON_RAIL, OFF_RAILの4パターン。
ダメージ受けない（乗る）、常に即死、レールに乗ってるときだけやられる、レールに乗ってない時だけやられる。うん。

lifeはデフォルトInfinityでsleepCountもデフォルト0で。引数に入れず、設定する場合は特殊なので、メソッドで設定することにする。
Infinity量産するのもなんかね。あれだし。
setLife(lifeCount, sleepCount){~~~~~}
で、trashを用意してlifeCountに達したら放り込んでsleepCountまでproperFrameCountを増やし続けてsleepCountに達したら出して・・
もろもろリセットして復活させる。だからproperFrameCountは常に増やせないといけないのね。
kill()のところに「sleepCountが正の場合はproperFrameCountを0にする」と記述し、trash内では「sleepCheck()」を実行させる。
sleepCheck()ではproperFrameCountを増やし続けsleepCountに達したらもろもろのリセット処理reset()を実行させる。で、その際に
aliveがtrueになる。aliveがtrueのレールはtrashから排除され元のrailsに戻る。そういう仕組みね。

calcTangent()について。
proportionに対して計算する。proportion * length ± 1をproportionで割る。で、[0, 1]でconstrainして、ふたつ取る。
それらは異なる点を与えるので結んで正規化して単位ベクトルにするだけ。

オブジェクト側：
プロパティについてはまあ、レール無視する敵とか敵の弾とかだったらavoidRailとかフラグ作ってこれがtrueの場合はレールに乗せない、
まあいいや。プロパティ。
avoidRail:デフォルトfalse.これがtrueのとかはクラス派生でいじる。レールに乗るかどうかってやつ。
manualVelocity, accellVelocity.
manualVelocityは操作により生じる加速度でレールに乗る前、乗った後での変化はなし。accellVelocityはレールに乗るたびにリセット。
これらを別々に更新してレール補正して大きさで抑えてその値を次も使う。
で、updateとdraw.

updateとdrawに分けて考える。
update側：
まずレールに乗ってるかどうかで処理を分ける。moveをプロパティ化する。
offRailMoveとonRailMoveをプロパティにしてPlayerの場合に特別なそれを設定してプレイヤーを動かす。
レールに乗ってない時はoffRailMoveで乗ってるときはonRailMoveを実行するっていうのをupdateの大枠にして。
あとcheckも。
PlayerのoffRailMoveの流れ。
左右のキー入力を見てあれば右優先で加速（大きさの上限あり）、無ければfrictionで減速
上下のキー入力は無視。frictionで減速
重力加速度鉛直下向きの補正をaccellに加える。大きさの上限あり。
合計に従って位置補正。
PlayerのonRailMoveの流れ。
forceがtrueの場合：pointerに従って位置補正、accellVelocityはすでに0にしてある。manualだけいじる。とはいえ接線調べて
常に用意しておくだけだけど。あー、要らないか？離脱時にレール情報から受け取ればいいか。うん。
やめた。位置補正だけして離脱時にforceがtrueだったらpointerの値と接線情報から速度を設定することにしよう。accellは常に0で飛び出すときも0とする。
円軌道の場合とかいちいち毎フレーム計算するのもあれだし（不要だし）。
って思ったけどやっぱ毎フレーム計算しよう・・どっちにしろ同じだ・・接線情報とpointerの値からmanualの速度は随時計算する。
forceがfalseの場合：上下左右のキー入力に従って加速なりfrictionなりしてmanualを設定。
accellの方はaccelerationがundefinedでなければその方向で足す感じ。これはスカラー値。接線ベクトルを計算してできる加速度を足す。
ごめんなさいベクトルですこれ。で、普通に足す・・で、接線で射影取って大きさ補正。
それらの速度について射影を取り、大きさで抑えて、それらの値を次のフレームとか離脱時に使うんだけど、
位置更新の時はスカラーだけ取り出してproportion更新で位置を更新する。まあ、当然・・はみ出したらえらいことになるので。
で、その更新の際に、reverseがfalseなら元に戻すのよ。0より小さくなったら1側、1より大きくなったら0側。
reverseがtrueだとして、それで0より小さいか1より大きい時、ストッパーを見て、trueならconstrainするけど、falseなら離脱処理を行う。
PlayerのCheckの流れ。
画面外に出た時にkill()みたいのをここに書く。
Player以外のoffRailMoveの流れ。
Playerと違ってばかみたいに直進してもいいし勝手にふよふよランダムウォークしてもいいしPlayerの方に向かってきてもいいし
いろいろ。円軌道まわってもいいし。レール無視していいので。
まあレールの上を回るってすれば行動になるけど。んー。
Player以外のonRailMoveの流れ。
そもそもレールに乗るかどうかってのがあって・・まあ乗るけど。乗ってからは基本一緒、インプットのところをたとえば右オンリーとか左オンリーとか
プレイヤーのいる方向に上下左右キーを入力するとかそこら辺。いない時は動かないとか。同じレールに乗ってるときだけ動くとか、いろいろ。
千差万別。
Player以外のCheckの流れ。
画面外に出た時にkill(),もしくはライフがあってproperFrameCountがそこに達すると消えるとか。
あとは周期的にattackとか？もしくは確率判定でattack, それらのタイミングでプレイヤーに向かってショット、以下略。
update(){
  onRailMove/offRailMove, check, attack
}
ジャンプと離脱
ジャンプ：
レールがbind:falseのときに可能で、accellを鉛直上向きの速度に固定する。左右は入力時のものが使えるから左右ジャンプが可能。
上だったら高いジャンプもできるってわけね。逆に下だと低いジャンプになったり。これでしかたどり着けない場所を作ったりもできるのでうまく作らないと・・
離脱：
やはりレールがbind:falseの時に可能、これはmanual,accellいずれの速度もそのまま使ってレールから外れるだけ。
自由落下や水平投射みたいになる。以降はoffRailMoveに従う。
トランジション（レールからレールに乗り移る場合）：
これは離脱ではないので・・レールに乗る処理なので、普通にaccellを0にしてmanualは継続、いっしょ。普通に乗るときといっしょでいい。

第二段階はまた別の機会に考えるということで・・

あー、そうね。上向きの円弧（下が開いている）で下向き重力ではしっこopenだったら面白いわね（両側から落ちていく）。

// ------------------------------------------------------------------------------------------------------------------------ //

ダメージレールはオーラをまとわせて区別したい。動きを持たせて分かりやすくしたい。たとえばstrokeを太くして範囲をまわすとか・・
20%くらいの範囲でしゅいーんしゅいーんみたいな（？？）

描画部分をどういじるか。
ストッパーがある場合は端っこに縦線（垂直線）。短い。太さは一緒で長さは固定。端っこで接線を毎フレーム計算して・・まあ、そういう感じで。
ポインターがある場合はそれを走らせる。同じ感じの線を。位置はポインターの方で計算してくれる。
加速度がある場合は真ん中あたりに正方形と三角形を組み合わせてできる白い矢印をふよふよさせて。長さは同じでいいから。めんど・・

一応、レールの方修正終わりました・・
キャパシティとかは廃止ですね。とりあえずいくつか作ってみてそれで実験とかする感じなので。
明日以降objectの方いじりますけどとりあえずproperFrameCountに統一するところからですね・・

いろいろ考えたけどストッパーだけでいいか。たとえばまっすぐ進むとかもありだろうし。
ストッパーも要らないかな・・（緑とか赤のノコノコを想像しながら）
じゃあもう完全にレールに乗るかどうかだけって話になるわね。どんどん変化していく。

reactionってプレイヤーだけがダメージレールでダメージ受けるのに普通にやばいやんね・・これね、
プレイヤーにブリンク用意して・・んー。そうそう、即死やめて反射にしよう、ダメージ受けて反射、そういう案もあったんだけど。
まあブリンクとかは用意するけど。
HPとかは、これもオブジェクトによっては、ないからなー・・ギミックとか。たとえば円レールをぐるぐる回るだけとか。そういうのも
想定、マリオでバブルって倒せないけどああいうのイメージしてる。はい、次。
reactionは個別。

すげぇめんどくさいいいいいい
めんどくさいいいいいいいいいう

あれ・・何からやればいいのか分かんない・・・あれ？？？？
やっぱマニュアルスピードは

できた（なぜ）

では次。仕様変更、第二段階。実行はまとめが終わってからね。

================================== オフセット =====================================
何はともあれオフセット用意しないと強制スクロールも作れない。
あとセーブポイントやワープゾーンですかね・・・・
AREA_WIDTHとAREA_HEIGHTはSCREEN_WIDTHとSCREEN_HEIGHTに改称
それとは別にSTAGE_WIDTHとSTAGE_HEIGHTを用意する。
？？
ああ、STAGE_の代わりにAREA_にしてSCREEN_を画面の大きさにしよう。そういうことになった。

オフセットの仕様

aw, ahはAREA_WIDTHとAREA_HEIGHTで、全体の大きさ。
sw, shはSCREEN_WIDTHとSCREEN_HEIGHT. 表示する画面の大きさ。

------ エリア用オフセット ------
まずプレイヤーの位置を(x, y)としてこの(x, y)が(sw/2, sh/2)～(aw-sw/2, ah-sh/2)の範囲にあるときに・・
じゃなくて、オフセットの範囲が(0,0)～(aw-sw, ah-sh)ですね。で、この値から(sw, sh)の範囲を描画する。
オフセットをプレイヤーの位置から計算する。横と縦に分ける。
横は0～sw/2のとき0でsw/2～aw-sw/2のときx-sw/2でaw-sw/2～awのときaw-swなので要するにmax(min(x-sw/2, aw-sw), 0)だ。
yの方もmax(min(y-sh/2, ah-sh), 0)だろ。
次に、オフセットから作られる矩形(ox, oy)～(ox+sw,oy+sy)に対し、これの外にあるレールは描画しない。
仕掛けを動かしてレールが出現するときにカメラが動いてその場所まで動いてっていうのをやりたいかも。だからオフセットの計算するところは
グローバルにして誰でも使えるように。クラスのメソッドでもいいけど。いいのか？
外にあるレールは描画しない・・衝突判定も要らないか。
線分の場合は適切な計算の仕方があって・・あるはず。円と弧は中心と半径で楽に判定しようね。
線分はminとmaxで雑に判定するか・・その方が楽。
xのmaxがエリア外、xのminがエリア外、yの・・って4つの条件作ってヒットしたら描画しないみたいな。
描画負荷を考えたらこっちの方がトータルでは速いはず。加えて判定からもスルーさせるのでもっと速い。この処理は毎フレームの一番最初に
やることにする。と思ったけど・・
画面外でレール上に敵がいた時にレール判定しないとやばいのか。。？んー。まあ、やめとくか。
描画だけしないことにしましょう。
grを新しく用意してそこに描画し、imageで落とす。描画に使うもろもろの数字はオフセット分だけ引く。

------ 背景用オフセット ------
問題は背景なんだけど、繰り返しの模様になる、で、若干広めに背景作っておく（80くらい・・sw+160,sh+160とか）。で、
たとえば格子で正方形が整列しているなら、間隔を40として、オフセットが40動くたびにリセットだから、背景のオフセット・・
背景のオフセットは0～40でいいわけ。つまり(0, 0)～(sw+marginX, sh+marginH)って感じかしらね。とはいえ上に行く場合もあるから
やっぱ(-mw, sw + mw, -mh, sh + mh)って感じかな・・ですねー。
縦方向も0～40でいいことになるけど。
オフセットを40で割った余りを使っている。
オフセットはベクトルである。それの横と縦の単位ベクトル基準で見た時の余り・・だからそれが斜めの場合でも同じように考える。
それらのベクトルの一次結合で書いたときの余りの部分だけ抜き取ってそれでオフセットにすればOK.
一次結合で書いて整数+(0～1)としてこの0～1を基底ベクトルに掛けて一次結合したものをオフセットとする。これで普通に動く。
基底ベクトルは模様によりけり。いちいち全部描画するのはあほらしいので活用する。オフセットと基底ベクトルから0～1、さらに
背景用オフセットを計算するのはグローバルで用意しておく。ユーティリティってやつね。内積計算で簡単に出せる。

横スクロールで8000x640とかやってみたい・・
強制スクロールは当たったら一発アウトの線が動いてぐーっと
上に動いてもいいし下に動いてもいいし両方に用意されててもいいよね。

やられたときのパーティクルから作ろうか。STGのやつにしよう。そのまま移植すればいいよ、まあ、のんびりやろう。
パーティクル暫定ですがこれで。若干いじりました、ていうかparticleSetって何。。。まあいいや。
動きの部分だけでいいやってなったときに廃止したんだけどなぜか残ってしまったという（（

ステージクラスどうしようって話になってる
ステージの中にさらに下位のエリアっていうクラスを設けていくつかのクラスを渡り歩くとか
ワープゾーン使って互いに行き来とかしても面白そう
オフセット設けるだけならすぐ終わるんだけど。。
ステージはエリアの集合で、エリアごとに3200x640とか800x1280とかいろいろ決まってる感じ。1000x1000とか。
もちろんその大きさのキャンバスがあるわけではなくてキャンバスの大きさは800x640で固定でこれがSCREEN_WIDTHとSCREEN_HEIGHTになる。
AREA_WIDTHとAREA_HEIGHTは現在存在しているエリアの横と縦になる。定数ではなく、クラスのプロパティになるわけ。

つまり・・・
1:エリアクラスを実装
2:エリアの集合としてステージを実装
3:オフセット
という流れ？エリアの横と縦がないことにはオフセット実装できないし・・
システムにどのエリアにプレイヤーがいるかの情報を・・エリアに敵やレールの情報が入ってるからそれで。
エリアごとにその、今までシステムが管理してたあれこれを持たせる。結局、システムが全部管理、ということになるとひとつの
エリアから外に出せないので。で、そうなるとプレイヤーをオブジェクト集合の一部として扱うのは無理が出てくるからやめようね。
--------って思ったけどすべてのエリアのオブジェクト配列にプレイヤーぶち込んでおいても特に問題ないか・・やっぱいいや。-------
エリアを渡り歩くのでいろいろ残機とか引き継ぐ必要が出てくるし（エリアをまたぐごとにオートセーブ、倒れたら
途中からやり直し）。個別に調べる感じで。なんなら一時的にpush/popすれば配列として従来通り扱えるでしょ。んー。
やめよ・・やっぱプレイヤーは個別に・・やられたときに復活させる必要ある。
スタート時にどのエリアにプレイヤーをおくとかそこら辺も。

ワープゾーンとかクリアラインとか・・クリアライン通過するとプレイヤーにクリアフラグが立って
それをエリア経由でステージが受け取ってクリアのアニメかなんか（雑）やってそれ終わったのをシステムが受け取って
次のステージに送るなりなんなりする感じ。もしくは選択画面に戻るとか。
そこまで複雑なのは現時点では考えてない。
ポーズから選択画面に戻ったりできる。クリアしたステージにはチェックが付いて再チャレンジできる。そんな感じ。
そこまで作ったことないから未知の世界だけど・・
セレクトの方もクラスにして・・そうねー。
ステージ開始時のアニメーションとかもステージが担当する。その間drawはするがupdateはしない感じ。

流れをまとめると・・
ステージ選択画面から始まる。1-1とか選ぶ。
エンターキー
ステージにはもう既にエリアが登録されててエリアにはレールとかそこら辺、配列がもう出来てる感じ。敵とか。
よく考えたらすべてのエリアにプレイヤーのポインタを持たせておけば済む話か・・分ける必要は、ない！

流れ。
ステージを生成するとき、ステージデータに基づいてエリアが生成される。エリアにはそれぞれレールとオブジェクトが
用意される。プレイヤーはあらかじめ生成しといてそれぞれのエリアのオブジェクト配列にポインタが放り込まれるが
初期位置に関してはエリアごとに違うので決めない。つまりブランク、エリアが始まるたびにセットする。
プレイヤーの位置は決めない！！（そりゃそうよね今ってひとつのステージでやってるから）
ステージにプレイヤーの情報を持たせておく。エリアごとのスタート位置の情報も。で、ステージ側でプレイヤーの位置を操作する。
で、システム側はまずセレクト画面から始める。セレクトクラスを用意してそっちがインタラクションなどもろもろを行う。
要するに権限移譲ね・・・
システムはすべてを統括する。
セレクトはステージ選択をインタラクションに基づいて行い、結果をシステムに報告。描画や更新（セレクト画面のアニメーションやるなら
更新もあるだろ・・）とか？で、システム側はそれに基づいてプレイヤーを然るべきステージ・・だから、それ以降はステージをセット、
ステージがdrawやupdateを・・同じ？ああこれGameStateか・・そうね・・
じゃあもうGameState作っちゃうか？？Title, Select, たくさんのStageって？
PlayやめてStageにする。複数の。Selectの結果をもとにどのStageに送るか決める。Pauseは？Stageの画像を流用して
透明度かけて・・かなぁ。まあそれはおいおいでいいけど。とりあえずSelectとStageいくつかだけ作りたい。
エリアごとの連携も後回しでいい。まずは3つのStageと3つのエリア（ひとつずつ付与）、Select.
そのあと複数エリアの連携とかTitleとかPauseとか用意する流れ。しばらくはやられても特定の場所から始まる感じにしてGameOverは用意しない。
ClearはアニメーションにするのでStateを用意することはないかも。Stageがやる感じ。ああでもPauseと似たような感じで作れるか？
透明度かけて・・うん。
じゃあPauseとGameoverとClearまとめてあとで作るよ。

流れ（固まるまで何回でも書く）
------ レールについて仕様変更 ------
まずbindレールをやめて、bindは付加属性にする。つまり、
bindの通常レール、フォースレール、アクセルレール、などなど。
通常レールを銀色、フォースレールを薄い緑、アクセルレールを薄い赤。で、
フロスティレールを薄い青（スピードが出にくいうえに減速も遅いなど慣性が大きいレール）、
マジカルレールを薄い紫（中央にマーカーが出てコンフィグに影響を与える）にする。ダメージレールの変更は無し。
マジカルレールは左右向きの矢印が出ている場合左右キーの入力がレールに乗ってる間だけ反転する。
上下向きの矢印の場合は上下キーの入力が反転する。両方出ているなら、両方反転する。

次に、SelectクラスとStageクラスを作る。
Selectクラスは3つくらい選択肢を用意して十字キーで選んでエンターで決定する感じ。
そのあとStageクラスに移行する。StageクラスはAreaクラスの配列を持っていてステージ選択時に生成する。
Stageクラスが、各ステージのレシピというかシードを持ってて、そのうち選択されたステージのシードをパースして、
Areaを生成、各Areaはレールや敵の情報を持っていて（とはいえとりあえずはレールだけでいいけど）、
もっというとAreaもひとつでいいけど・・・で、オブジェクト配列は作るときに（すべてのAreaに対し）
System側がPlayerを持っててそれを放り込む感じ。で、Area開始時にスタート位置の情報をAreaが持ってるからそれについて
Playerの位置を決定する。そしてステージから出るまでの間それらの情報は保持される。ステージクリアして次のステージが始まるか、
もしくは離脱する場合にすべてのAreaの情報を破棄する。そして新しいステージのシードから新たにArea配列つくるとこからやり直し。
各種トランジション（ステージが始まるときとかAreaをまたぐときなど）はStageの仕事。
やっぱGameState---Select, PlayでPlayがStage持っててそれの下にArea...の方がいいかな・・んー。GameStateとして
扱うのはSystem側の記述を楽にするため。そうなるとStageがPlayの代わりというのは具合が悪いので。となると
PlayがStageをもっていてStageがupdateやdrawを行う、とした方がいろいろすっきりしそう。
PlayがStageSeedを持っていてそれを使ってStageの初期化やAreaの生成を行う。背景指定など。
Stageが描画する。どう描画するか？Stageがまず背景を描画する（Playerのオフセットを考慮する）。で、その上に
オフセット込みでAreaがレールやらなんやらを描画する。渡される。Stageから。grかなんかを。で、imageする。
その先も・・んー。
Playがグラフィック持ってて、それにStageが背景描いて、それにAreaがレールとかいろいろ描いて、Stageのタイミングで描画。
Pauseに移行するときは、Playのグラフィックを渡して、カバーかけて・・とかやる。戻すときは、戻すだけ。
ClearとGameoverはおいおい。

あーなるほど。
じゃあね・・ダメージレールの場合は・・あー、どうするかな・・
つまりあれ、インターセクションの場合、
えーと・・・
つまり・・
// で、同じタイミングであるがゆえにスルーされたっぽいね・・順番が先だから。
// やっぱ全部総当たりでやらないとだめってことね。
// つまり銀のレールと紫のレールを同時に通過したけど、なぜか・・なぜか、
なぜか、ジャンプにしても離脱にしてもレールに乗れないタイミングを作らないと外れることができないようになってる。んー。
UNRIDE_SPANを用意しないといけない。5フレームでうまくいってる。理由は分からない・・やっぱ仕様に問題がある。
そこら辺解決してからレール増やしてPlayやSelect作って・・ってやった方がよさそう。
で、今回のバグ（銀レールと紫レールが交差するポイントぎりぎりでジャンプすると紫をすりぬけてしまう）は、
同じタイミングで両方を通過した場合に前者で判定がなされると後者はスルーされる、っていうのが原因だった。
間違いない。紫を一番最初に持ってきたらbreakがあってもそっちの判定受けた。ちゃんと。ということは、
似たような状況の場合には（配列において）手前の方が優先されるってことかな・・乗り移るにしてもダメージ受けるにしても。
ステージの作り方に工夫が要りそう。紫すり抜けられちゃうんじゃやってられないでしょ。

とりあえずジャンプと離脱で再び乗ってしまう謎は解明しないとね・・・

criterion使って0のとき～とかやってるけど、
前のフレームで乗ってました、の方が正確かもしれない。
つまり、前のフレームでのisBelonging的なあれを用意する。
dataからisBelongingを独立させて、それのpreviousを用意して、それがtrueのときは交差判定しないようにする。
その方が確実。あとarcは計算通りに修正してね。それでwaitCountは必要なくなるはず。おねがい！！

無事、生還しました。
なので続きを書きます。
step1:Arc修正
step2:ShiftとSpaceの方はwaitを設定しないけど乗換では設定する
step3:previousRailを設定して直前にそのレールに乗っていた場合はスルー
step4:複数のレールを同時に通過した場合の処理→やめようね。適当に作るわ。これ違反しないように。

オートマタ作るんならオブジェクトの継承やってね
waitCount復活させました。やっぱ動かない。まあ、仕方ない。prevRailは一応実装したけど。
円は難しいね。やっぱ難しい。
とりあえずこんなもんで。またバグ出たらなんとかしますよ。多分。

まず交叉が確定したレールをダメージとそれ以外に分けて・・問題はダメージであってもきちんと交叉を調べないといけない、
でないと先に当たったかどうかわからないっていう。で、交叉ポイントが出そろったらそれとpreviousPositionとの距離でソートして
順繰りに調べていく、乗れるならそこで乗って終わり。ダメージレールならkillの場合はkillして終わり、killでないならスルーして次。
すべてダメージレールならkillかオールスルーで終わり、乗れるのがあったら乗って終わり、そこから先は無視。こんな感じ。
実はダメージレールであってもきちんとproportionを計算しているのでcalcPositionFromProportionで位置を出せる。
だからそれを出そろわせることも可能だしソートもできる。
オブジェクトで小さい順に並べるには
[配列でキーkeyをもちkeyの小さい順に並べたい].sort((u, v) => u.key - v.key)
って感じ。これで行ける。で、・・・オブジェクトとしては{rail:_rail, distFromPrev:previousと交差点との距離}で。
そんで、順繰りに・・trueが出たらbreakする。trueを返すのはレールに乗った時とダメージレールでkillしたときだけ。
でもよく考えたらマージン設けてるんだよな・・まあ、いいや。

複数のレールに同時に接触することがそもそもまれだから仕方ないよな。
