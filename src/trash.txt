let _rail0 = new LineRail({railType:NORMAL_R, stopper:[true, true]}, 50, 200, 250, 300);
let _rail1 = new LineRail({railType:NORMAL_R}, 200, 50, 50, 300);
let _rail2 = new LineRail({railType:ALL_KILL_R}, 5, 5, 400, 5);
let _rail3 = new LineRail({railType:ALL_KILL_R}, 5, 5, 5, 480);
let _rail4 = new LineRail({railType:FORCE_R, pointerSpeed:4, pointerReverse:true, stopper:[false, true]}, 240, 400, 740, 400);
let _rail5 = new LineRail({railType:BIND_R, pointerSpeed:8, pointerReverse:false, stopper:[true, false]}, 300, 500, 300, 80);
//let _rail6 = new LineRail({railType:ONRAIL_KILL_R}, 400, 40, 400, 600);
//let _rail7 = new LineRail({railType:OFFRAIL_KILL_R}, 600, 40, 600, 600);
let _rail8 = new CircleRail({railType:FORCE_R, pointerSpeed:4, pointerReverse:false}, 100, 500, 80);
let _rail9 = new ArcRail({railType:NORMAL_R, stopper:[true, true]}, 500, 400, 200, -PI * 0.5, PI);
let _rail10 = new LineRail({railType:ACCELL_R, acceleration:createVector(0, 0.3)}, 600, 20, 400, 220);

/*
レール作りのメソッドはこの辺に避難させとく
// ここでレールを作る。点とか指定する。速度とか。とりあえずデモでは端っこで折り返して勝手に消える感じでいいんじゃない。
let p1, p2;
if(Math.random() < 0.5){
	p1 = createVector(AREA_WIDTH * (0.1 + 0.15 * Math.random()), AREA_HEIGHT * (0.05 + 0.9 * Math.random()));
	p2 = createVector(AREA_WIDTH * (0.9 - 0.15 * Math.random()), AREA_HEIGHT * (0.05 + 0.9 * Math.random()));
}else{
	p1 = createVector(AREA_WIDTH * (0.05 + 0.9 * Math.random()), AREA_HEIGHT * (0.1 + 0.15 * Math.random()));
	p2 = createVector(AREA_WIDTH * (0.05 + 0.9 * Math.random()), AREA_HEIGHT * (0.9 - 0.15 * Math.random()));
}
let direction = p5.Vector.sub(p2, p1).heading() + Math.PI * 0.5;
let speed = 1 + Math.random();
let newRail = new LineRail(NORMAL_R, 240 + 120 * Math.random(), p1, p2, p5.Vector.fromAngle(direction, speed));
newRail.setMove((_line) => {
	const {p1, p2} = _line;
	const c1 = (p1.x < 0 || p1.x > AREA_WIDTH || p1.y < 0 || p1.y > AREA_HEIGHT);
	const c2 = (p2.x < 0 || p2.x > AREA_WIDTH || p2.y < 0 || p2.y > AREA_HEIGHT);
	if((c1 || c2) && _line.waitCount === 0){
		_line.velocity.mult(-1);
	}
});

let c = createVector(AREA_WIDTH * (0.3 + Math.random() * 0.4), AREA_HEIGHT * (0.3 + Math.random() * 0.4));
let v = p5.Vector.fromAngle(Math.PI * 2 * Math.random(), 2.5);
let r = Math.min(AREA_WIDTH, AREA_HEIGHT) * (0.05 + 0.2 * Math.random());
let newCircle = new CircleRail(NORMAL_R, 360, c, v, r);
newCircle.setMove((_circle) => {
	_circle.center.add(_circle.velocity);
	const {x, y} = _circle.center;
	const {x:vx, y:vy} = _circle.velocity;
	const r = _circle.radius;
	if(x - r < 0 || x + r > AREA_WIDTH){
		const diffX = (x - r < 0 ? (r - x) / vx : (AREA_WIDTH - r - x) / vx);
		_circle.center.add(p5.Vector.mult(_circle.velocity, diffX));
		_circle.velocity.x *= -1;
	}else if(y - r < 0 || y + r > AREA_HEIGHT){
		const diffY = (y - r < 0 ? (r - y) / vy : (AREA_HEIGHT - r - y) / vy);
		_circle.center.add(p5.Vector.mult(_circle.velocity, diffY));
		_circle.velocity.y *= -1;
	}
})

let c = createVector(AREA_WIDTH * (0.3 + Math.random() * 0.4), AREA_HEIGHT * (0.3 + Math.random() * 0.4));
let v = p5.Vector.fromAngle(Math.PI * 2 * Math.random(), 2.5);
let r = Math.min(AREA_WIDTH, AREA_HEIGHT) * (0.05 + 0.2 * Math.random());
let newArc = new ArcRail(NORMAL_R, 330, c, v, r, 2 * Math.PI * Math.random(), Math.PI * (0.2 + 1.6 * Math.random()),
												 (1 + Math.random()) * random([1, -1]) * 0.01);
newArc.setMove((_arc) => {
	_arc.t1 += _arc.angleSpeed;
	_arc.t2 += _arc.angleSpeed;
	_arc.center.add(_arc.velocity);
	// めんどくさいので円の場合の反射処理を援用する。どうせ最終的な実装では使わないので・・
	const {x, y} = _arc.center;
	const {x:vx, y:vy} = _arc.velocity;
	const r = _arc.radius;
	if(x - r < 0 || x + r > AREA_WIDTH){
		const diffX = (x - r < 0 ? (r - x) / vx : (AREA_WIDTH - r - x) / vx);
		_arc.center.add(p5.Vector.mult(_arc.velocity, diffX));
		_arc.velocity.x *= -1;
	}else if(y - r < 0 || y + r > AREA_HEIGHT){
		const diffY = (y - r < 0 ? (r - y) / vy : (AREA_HEIGHT - r - y) / vy);
		_arc.center.add(p5.Vector.mult(_arc.velocity, diffY));
		_arc.velocity.y *= -1;
	}
})
*/
